M = 16;
N = 32;
K = N - M;
% must use circulant
A11 = circulant([0 0 1 0 0 0 0 1],1);
A12 = circulant([0 1 0 0 0 1 0 0],1);

A13 = circulant([0 0 0 1 1 0 0 1],1);   % 3 ones
A14 = circulant([1 0 1 0 0 0 0 1],1);   % 3 ones

A21 = circulant([1 0 0 0 0 0 1 0],1);
A22 = circulant([1 0 1 0 0 0 0 0],1);

A23 = circulant([0 0 0 1 0 0 1 1],1);   % 3 ones
A24 = circulant([0 1 0 0 1 0 0 0],1); % 3 ones

A = [A11 A12 A13 A14
     A21 A22 A23 A24];

C1 = [A11 A12
      A21 A22];

C2 = [A13 A14
      A23 A24];

rank(gf(C2,1));
% Convert BOTH to GF(2)
C1gf = gf(C1,1);
C2gf = gf(C2,1);

C2i = inv(C2gf);
Pgf = C2i * C1gf;

P = double(Pgf.x);   % <-- convert to double
P = mod(P,2);

H = double(mod([P eye(M)],2));
GT = double(mod([eye(K); P],2));

u = double([1 0 0 1 1 0 0 1 0 1 0 1 1 0 1 0]);
c = mod(u*GT.',2);

%% ================= CHANNEL =====================

% BPSK mapping: 0 -> +1, 1 -> -1
x = 1 - 2*c;

% Add AWGN
EbN0_dB = 6;              % try different SNRs
R = K/N;
EbN0 = 10^(EbN0_dB/10);
sigma2 = 1/(2*R*EbN0);

noise = sqrt(sigma2) * randn(1,N);
y = x + noise;

% Channel LLR
Lch = 2*y/sigma2;


%% ================= DECODE =====================

maxIter = 50;
[c_hat, iter] = spa_decoder(H, Lch, maxIter);

disp('Original codeword:')
disp(c)

disp('Decoded codeword:')
disp(c_hat)

disp(['Iterations used: ' num2str(iter)])
disp(['Syndrome check: ' num2str(all(mod(H*c_hat',2)==0))])

error_vec = xor(c, c_hat);

function [c_hat, iter] = spa_decoder(H, Lch, maxIter)

H = double(H);
[M,N] = size(H);

q = zeros(M,N);   % variable -> check
r = zeros(M,N);   % check -> variable

% ================= Initialization =================
for j = 1:N
    idx = find(H(:,j));
    for i = idx'
        q(i,j) = Lch(j);
    end
end

% ================= Iterations =====================
for iter = 1:maxIter

    %% ===== CHECK NODE UPDATE (Eq. 10 / 11 paper) =====
    for i = 1:M
        
        idx = find(H(i,:));
        d = length(idx);
        
        alpha = tanh(q(i,idx)/2);
        
        % Forward products
        F = zeros(1,d);
        F(1) = alpha(1);
        for k = 2:d
            F(k) = F(k-1) * alpha(k);
        end
        
        % Backward products
        B = zeros(1,d);
        B(d) = alpha(d);
        for k = d-1:-1:1
            B(k) = B(k+1) * alpha(k);
        end
        
        for k = 1:d
            
            if k == 1
                prod_ex = B(2);
            elseif k == d
                prod_ex = F(d-1);
            else
                prod_ex = F(k-1) * B(k+1);
            end
            
            prod_ex = max(min(prod_ex,0.999999),-0.999999);
            r(i,idx(k)) = 2 * atanh(prod_ex);
        end
    end

    %% ===== VARIABLE NODE UPDATE =====
    for j = 1:N
        
        idx = find(H(:,j));
        
        for i = idx'
            others = idx(idx ~= i);
            q(i,j) = Lch(j) + sum(r(others,j));
        end
    end

    %% ===== Posterior LLR =====
    Lpost = Lch;
    for j = 1:N
        idx = find(H(:,j));
        Lpost(j) = Lch(j) + sum(r(idx,j));
    end
    
    c_hat = (Lpost < 0);

    % Stop if valid codeword
    if all(mod(H*c_hat',2) == 0)
        break;
    end
end
end
